<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="content-language" content="de">
    <meta name="language" content="de">
    <meta name="description"
        content="Reto Weber - programming, research, politics, books, religion, philosophy and science.">
    <meta name="author" content="Reto Weber">
    <meta name="keywords"
        content="Reto Weber, programming, research, politics, blog, books, religion, philosophy, science, blog, science, computer-science, machine-learning">
    <meta name="robots" content="index, follow">

    <!-- Open Graph (for rich previews on social platforms) -->
    <meta property="og:title" content="Science">
    <meta property="og:description"
        content="Reto Weber - programming, research, politics, books, religion, philosophy and science. [blogsciencecomputer-sciencemachine-learning]">
    <meta property="og:type"
        content="article">
    <meta property="og:url" content="/de/blog/science/">
    <meta property="og:site_name" content="Reto Weber">
    <meta property="og:image" content="/output.png">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Science">
    <meta name="twitter:description"
        content="Reto Weber - programming, research, politics, books, religion, philosophy and science. [blogsciencecomputer-sciencemachine-learning]">
    <meta name="twitter:image" content="/output.png">

    <!-- JSON-LD Structured Data for rich results -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/de/blog/science/"
      },
      "headline": "Science",
      "description": "Reto Weber - programming, research, politics, books, religion, philosophy and science. [blogsciencecomputer-sciencemachine-learning]",
      "author": {
        "@type": "Person",
        "name": "Reto Weber"
      },
      "publisher": {
        "@type": "Organization",
        "name": "Reto Weber",
        "logo": {
          "@type": "ImageObject",
          "url": "../../../favicon.ico"
        }
      }
    }
    </script>

    <title>Science - Reto Weber</title>
    
    <link href="../../../assets/rss-feed.css" rel="stylesheet">

    </noscript>


    <link rel="stylesheet" href="../../../style.css">
    <link rel="preload" href="/fonts/inter.woff2" as="font" type="font/woff2" crossorigin fetchpriority="high">
    <link rel="preload" href="/fonts/gidole.woff2" as="font" type="font/woff2" crossorigin fetchpriority="high">
    <style type="text/css">
        @font-face {
            font-family: 'Gidole';
            src: url('/fonts/gidole.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Inter';
            src: url('/fonts/inter.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Inter';
            src: url('/fonts/inter.woff2') format('woff2');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }
    </style>


    <link rel="icon" type="image/svg+xml" href="../../../favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    
    
    
    
    
    
    
    
    
    
    
    <header class="site-header">
        <div class="site-title">
            <h1 class="">
                <a href="/index.html">Reto Weber</a>
            </h1>
        </div>
        
        <ul class="main-nav">
            
            
            
            
            <li class="nav-parent ">
                <a href="../../programming/buchfaltstudio/">Programmierung</a>
                <ul class="nav-dropdown">
                    
                    <li class="">
                        <a href="../../programming/buchfaltstudio/">Buchfaltstudio</a>
                    </li>
                    
                    <li class="">
                        <a href="../../programming/background-generator/">Hintergrund Generator</a>
                    </li>
                    
                    <li class="">
                        <a href="../../programming/parallelismus/">Parallelismus</a>
                    </li>
                    
                </ul>
            </li>
            
            
            
            
            
            <li class="nav-parent ">
                <a href="../../research/hoare-logic/">Forschung</a>
                <ul class="nav-dropdown">
                    
                    <li class="">
                        <a href="../../research/hoare-logic/">Hoare-Logik</a>
                    </li>
                    
                </ul>
            </li>
            
            
            
            
            
            <li class="nav-parent ">
                <a href="../../politik/finanzen-beringen/">Politik</a>
                <ul class="nav-dropdown">
                    
                    <li class="">
                        <a href="../../politik/finanzen-beringen/">Finanzen Beringen</a>
                    </li>
                    
                </ul>
            </li>
            
            
            
            
            
            <li class="nav-parent current">
                <a href="../thoughts/">Blog</a>
                <ul class="nav-dropdown">
                    
                    <li class="">
                        <a href="../thoughts/">Gedanken</a>
                    </li>
                    
                    <li class="">
                        <a href="../philosophy/">Philosophie</a>
                    </li>
                    
                    <li class="current">
                        <a href="./">Wissenschaft</a>
                    </li>
                    
                </ul>
            </li>
            
            
            
            
            
            <li class="nav-parent ">
                <a href="../../book/the-book/">Buch</a>
                <ul class="nav-dropdown">
                    
                    <li class="">
                        <a href="../../book/the-book/">Das Buch</a>
                    </li>
                    
                    <li class="">
                        <a href="../../book/influential-books/">Einflussreiche Bücher</a>
                    </li>
                    
                    <li class="">
                        <a href="../../book/lessons-from-my-book/">Lektionen aus meinem Buch</a>
                    </li>
                    
                </ul>
            </li>
            
            
        </ul>
        
        
        <nav class="language-switcher" aria-label="Language selector">
            
            
            
            
            
            
            <a href="../../../blog/science/" class="">English</a>
            
            
            
            
            
            
            
            <a href="./" class="active">Deutsch</a>
            
            
        </nav>
        
        <form class="search-form" role="search">
            <input type="search" id="mkdocs-search-query" name="q" placeholder="Search..." autocomplete="off">
        </form>
        <a href="https://forms.gle/VBaJXfvzMupony487" target="_blank" class="feedback-button">
            Feedback
        </a>
    </header>
    <div id="main-container">
        <div class="toc-container">
            <ul class="toc-list ">
                
                
                <li>
                    <a href="#ein-gedanke-zu-vibe-coding">Ein Gedanke zu Vibe-Coding</a>
                    
                    <ul>
                        
                        <li class="toc-sub">
                            <a href="#computer">Computer</a>
                        </li>
                        
                        <li class="toc-sub">
                            <a href="#heute">Heute</a>
                        </li>
                        
                        <li class="toc-sub">
                            <a href="#llms-sind-die-erste-hochsprache">LLMs sind die erste Hochsprache</a>
                        </li>
                        
                        <li class="toc-sub">
                            <a href="#wie-bereiten-wir-uns-vor">Wie bereiten wir uns vor?</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="#was-haben-wir-gelernt-und-einige-fundierte-vermutungen">Was haben wir gelernt? Und einige fundierte Vermutungen</a>
                    
                    <ul>
                        
                        <li class="toc-sub">
                            <a href="#godels-unvollkommenheitstheorie">Gödels Unvollkommenheitstheorie</a>
                        </li>
                        
                        <li class="toc-sub">
                            <a href="#komplexitatstheorie">Komplexitätstheorie</a>
                        </li>
                        
                        <li class="toc-sub">
                            <a href="#halteproblem">Halteproblem</a>
                        </li>
                        
                        <li class="toc-sub">
                            <a href="#chaostheorie">Chaostheorie</a>
                        </li>
                        
                        <li class="toc-sub">
                            <a href="#gradientenoptimierung">Gradientenoptimierung</a>
                        </li>
                        
                        <li class="toc-sub">
                            <a href="#spieltheorie">Spieltheorie</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="#evolution-simulieren">Evolution simulieren</a>
                    
                </li>
                
                <li>
                    <a href="#pytorch-ist-langsam-und-schnell-unter-windows">PyTorch ist langsam und schnell unter Windows</a>
                    
                </li>
                
                <li>
                    <a href="#neuronale-netzwerke-komprimieren">Neuronale Netzwerke komprimieren</a>
                    
                </li>
                
                <li>
                    <a href="#ein-gescheitertes-experiment-gewichte-innerhalb-eines-neuronalen-netzwerks-komprimieren">Ein gescheitertes Experiment: Gewichte innerhalb eines neuronalen Netzwerks komprimieren</a>
                    
                </li>
                
                
            </ul>
        </div>
        <div class="content">
            
            <div class="auto-translation-banner" role="status">
                <strong>Automatische Übersetzung.</strong>
                
                
                Diese Seite wurde maschinell aus EN übersetzt und kann Fehler enthalten.
                
            </div>
            
            <!-- _Jede Wissenschaftsnotiz hat jetzt ihren eigenen Permalink; diese Seite behält das „lange Lesen“ als Gesamterlebnis bei.

## Recent Science Posts -->

<!-- <div class="rss-feed" data-rss-feed data-rss-prefix="/blog/science/" data-rss-limit="10">
    <p><em>Lade den Wissenschafts-Feed...</em></p>
</div> -->

<!-- AUTO-GENERATED: snippet list. Update individual posts instead. -->

<h1 id="ein-gedanke-zu-vibe-coding">Ein Gedanke zu Vibe-Coding</h1>
<p>Ich lese viele Artikel über dieses Vibe-Coding. Wobei der Begriff nicht mal genau definiert ist, aber ungefähr besagt: Programmieren mit integrierter Unterstützung durch ein LLM. Oder in anderen Worten: das durch künstliche Intelligenz unterstützte Programmieren. Ich selbst verwende es extensiv für viele unwichtige Angelegenheiten.</p>
<p>Ich möchte eine kleine Webanwendung machen für meine Präsentation: Easy. Mit Vibe-Coding geht das in 10 Minuten. Ich möchte meine Daten mit einem Skript auswerten. Die KI schreibt mir dieses Skript schnell. Und so weiter.</p>
<p>Gleichzeitig wird überall gewarnt vor den Gefahren der KI. Gerade die Open-Source-Community hat Probleme damit. Das Engagement an Open-Source-Projekten nimmt nämlich ab. Menschen möchten die Probleme von diesen Projekten gar nicht mehr fixen, sondern finden einen Workaround mittels KI. Die KI konnte die Library lokal ändern oder fand sonst einen Fix. Da der Programmierer selbst nur wenig Code am Ende noch liest, ist er sich gar nicht bewusst, dass ein Problem in einer Library existierte, und fährt fort, als wäre nichts gewesen. Diese Entwicklung (und viele andere) werden kritisiert. Ich möchte in diesem Artikel Parallelen zu vergangenen Entwicklungen aufzeigen und eine Prognose wagen, wohin sich die Programmierwelt entwickeln wird und wie wir uns darauf vorbereiten können.</p>
<h2 id="computer">Computer</h2>
<p>Vor 200 Jahren gab es den Beruf des «Computers». Es waren Menschen (meist Frauen), die im Kopf und mit Stift und Papier rechneten. Gab es ein mathematisches Modell für die Berechnung, konnte man diese Frauen anstellen und sie berechneten es. Menschen sind fehlerhaft und somit waren auch immer wieder Resultate falsch. Gleichwohl war es über eine lange Zeit eine wertvolle Aufgabe. Bis der moderne Computer kam. Eine Maschine, die genau das kann. Der Beruf wurde wegrationalisiert.</p>
<p>Stellen wir uns diese Zeit vor. Ein gebrauchter Beruf wurde überflüssig. Aber nicht nur das, auch die Open-Source-Community wurde getroffen. Es gab Bücher mit Logarithmus-Tabellen. Viele nützliche Dinge wurden überflüssig. All dieser Nutzen fiel weg.</p>
<h2 id="heute">Heute</h2>
<p>Aus meiner Sicht verhält es sich heute genauso. Viele wichtige Berufe werden überflüssig. (Meiner wahrscheinlich auch.) Doch was passiert, wenn auf einmal Aufgaben, die früher Wochen oder gar Monate dauerten, jetzt in Stunden gemacht werden können? Die ganze alte Infrastruktur für den Informationsaustausch wird überflüssig. Die Open-Source-Projekte werden sich ändern. Es geht nicht mehr um so kleine Sachen wie einen Bugfix, sondern um Features. Neue Fähigkeiten werden bereitgestellt.</p>
<p>Früher war eine Berechnung nur gültig mit korrektem Rechnungsweg. Mit dem Computer interessieren die Zwischenresultate niemanden mehr. Wenn der Algorithmus definiert ist, dann «glaubt» man einfach dem Computer, dass er das schon korrekt macht. Natürlich sind alle Hilfsmittel (Compiler usw.) ebenfalls wichtig. Doch sind viele davon auch nicht öffentlich, folglich muss einfach vertraut werden, dass sie funktionieren. Mit nicht quelloffenen Programmen wird die Kette gebrochen und wir können nicht nachvollziehen, ob ein Ergebnis korrekt ist. Das hat aber kaum jemanden interessiert in der Vergangenheit.</p>
<p>Mit KI verhält es sich gleich. Wir sind nicht mehr an einzelnen Commits interessiert, sondern an Blöcken. Commits werden nur vollständigkeitshalber gespeichert. Doch es wird eine KI-Zusammenfassung der Änderung geben und diese wird das wahre «Diff» sein. Wenn der Code nicht diesem «Diff» entspricht, dann ist das halt ein BUG. Ich glaube, die Menschheit benötigt kein Log für jede Millisekunde. Ich glaube, dass die Abstände zwischen den Logs (genauer gesagt die Grösse der Commits) abhängig von der echten Zeit sind. Ein Log/Commit pro 30min, aber vielleicht auch nur ein Log/Commit pro Halbtag. Was in dieser Zeit erledigt werden kann, wurde mit KI gesteigert, und dadurch werden die «Diffs» riesig. Ähnlich wie bei den Computern: Wir speichern nicht alle Rechenschritte. Wenn es neu berechnet werden kann innerhalb von 30 min, warum soll ich es speichern?</p>
<p>Wir benötigen so ein «Meta-Git». Am Anfang wird das eine LLM-Zusammenfassung von vielen Git-Commits sein. Doch dieses Meta-Git wird sich entwickeln und ein Standard wird kreiert werden. Dieses Mega-Git sollte langfristig weiterentwickelt werden. Wenn ein solcher einzelner «Meta-Commit» ganze Features beinhaltet (was früher ein Pull-Request war, ist heute ein Commit), dann wollen wir so Eigenschaften wie Assoziativität und Kommutativität. Die History dieser Änderungen wird irrelevant, sondern nur noch die semantische, konkrete Änderung. Schon beinahe isoliert von seiner Umgebung.</p>
<p>Was wir in Zukunft also teilen werden, wird sich verändern. Es werden nicht mehr normaler Code sein, sondern Features oder Komponenten. Wie solche gespeichert und angewandt werden auf andere Projekte usw., weiss ich nicht.</p>
<h2 id="llms-sind-die-erste-hochsprache">LLMs sind die erste Hochsprache</h2>
<p>Die Vision vieler Hochsprachen wie Pascal war es: Lasst uns einfach Englisch schreiben, was wir wollen, und der Computer macht es dann. Doch alle Ansätze funktionierten nicht. Es war immer einfach eine etwas lesbarere Version von einer puren Sprache. Viele wollten nicht die menschliche Sprache imitieren, sondern das menschliche Denken, und somit entstanden die objektorientierten Sprachen. Objekte sind da und tun etwas.</p>
<p>Aus meiner Sicht sind LLMs die Erfüllung dieser Vision. Jetzt können wir wirklich auf Englisch (oder sogar in einer anderen Sprache) ausdrücken, was wir wollen, und der Computer macht es. Es ist eine Revolution. Momentan sind noch immer die am effizientesten mit der KI, die es auch ohne KI machen könnten, doch ich bin mir nicht sicher, dass das so bleibt. Bzw. ich bin mir ziemlich sicher, dass es nicht so bleibt.</p>
<p>Ich erinnere mich noch gut an ein Gespräch mit einem alten Freund. Er war und ist sehr gebildet und intelligent (was nicht dasselbe ist). Er war jedoch eher sprachlich talentiert als mathematisch. Er erzählte mir von einem Aufsatz, den er als Auftrag schrieb, in dem er ad absurdum führte, dass ein Computer Menschen ersetzen könnte. Der hätte doch keine Kreativität, kein logisches Denken und keinen Antrieb. Dieser Aufsatz alterte schlecht. Ich sagte ihm schon damals, dass ich keinen fundamentalen Unterschied zw. Computer und Menschen finde und es kein Argument ist, es einfach absurd zu nennen. Es blieb bei diesem kurzen Austausch. Doch heute haben wir KIs mit Kreativität, Antrieb, und wenn wir die «Agents» zusammen mit einer Programmiersprache betrachten, dann besitzen sie jetzt auch Logik.</p>
<h2 id="wie-bereiten-wir-uns-vor">Wie bereiten wir uns vor?</h2>
<p>Diese Entwicklung wird sich nicht aufhalten lassen. Als Direktbetroffener werde ich von Anfang an die Tools nutzen, am Ball bleiben und versuchen, Probleme zu lösen, die ich zuvor nicht konnte. Meinen Berufsstolz muss ich liegen lassen und ein Ja zu einer neuen Denkweise finden. Ich glaube, für uns persönlich ist es hilfreich, möglichst am Ball zu bleiben. Und das aktiv. Lasst uns Projekte umsetzen und nicht nur Blogartikel lesen. Als Firma dasselbe. Haltet nicht krampfhaft an euren alten Prozessen fest. Evaluiert andauernd. Als Politik: Open Data wird so wichtig wie noch nie. Mit KI kann man die schnell anzapfen und sich Berichte erstellen lassen. Die Entscheidungsfindung in Zukunft wird viel datengestützter sein.</p>
<h1 id="was-haben-wir-gelernt-und-einige-fundierte-vermutungen"><a href="/blog/science/what-have-we-learned-and-some-educated-guesses/">Was haben wir gelernt? Und einige fundierte Vermutungen</a></h1>
<h2 id="godels-unvollkommenheitstheorie">Gödels Unvollkommenheitstheorie</h2>
<p>Gödel ist einer der grossen Mathematiker des letzten Jahrhunderts. Unter anderem arbeitete er an den Grundlagen der
Mathematik. Ihn interessierte die Frage, ob Mathematik «vollständig» ist. Um zu verstehen, was damit gemeint ist,
brauche ich zuerst kurz den Begriff des Axioms.</p>
<p>Ein Axiom ist eine Annahme in einem mathematischen System, die nicht bewiesen wird. Mathematik kommt ohne solche
Annahmen nicht aus. Ein bekanntes (wenn auch etwas vereinfachtes) Beispiel ist: $1+1=2$. Es wirkt so offensichtlich,
dass man versucht ist zu sagen: «Dafür braucht es keinen Beweis.» Genau das ist die Intuition hinter Axiomen.</p>
<p>Als Axiom wählt man Aussagen, denen (im gewünschten Kontext) alle zustimmen können. Das bedeutet aber nicht: «Was mir
offensichtlich erscheint, erkläre ich einfach zur Wahrheit.» Denn was für die eine Person offensichtlich ist, ist es
für die andere vielleicht nicht. Darum schreiben Mathematiker ihre Axiome explizit auf und sagen sinngemäss:
«Unter diesen Annahmen mache ich Mathematik.» Dann kann jede andere Person prüfen, ob die Schlussfolgerungen unter
diesen Annahmen korrekt sind.</p>
<p>Ein Beispiel für solche Annahmen:</p>
<ul>
<li>A: 0 ist eine Zahl</li>
<li>B: 1 ist eine Zahl</li>
<li>C: Wenn $x$ eine Zahl ist, dann gilt: $x + 0 = x$</li>
<li>D: Wenn $x$ eine Zahl ist, dann ist $x + 1$ auch eine Zahl</li>
<li>E: $x+1 &gt; x$</li>
</ul>
<p>Mathematiker würden (zu Recht) sagen, dass das nicht formal genug ist. Für unsere Zwecke reicht es. Und man sieht:
Solche Aussagen sind fast banaler Natur. Trotzdem lässt sich daraus bereits eine Aussage beweisen, die für Kinder
eine echte Offenbarung ist: «Es gibt keine grösste Zahl.»</p>
<p>Beweis durch Widerspruch:</p>
<p>Angenommen, es gäbe eine grösste Zahl. Nennen wir sie $y$. Dann folgt aus D, dass $y+1$ ebenfalls eine Zahl ist.
Nennen wir sie $z$. Aus E folgt $z&gt;y$. Das widerspricht der Annahme, dass $y$ die grösste Zahl ist. Also gibt es
keine grösste Zahl.</p>
<p>Das alles klingt nach spitzfindiger Haarspalterei, die Mathematiker betreiben, um Probleme zu lösen, die niemand hat.
Und genau so dachte ein grosser Teil der Mathematik zu Beginn des 20. Jahrhunderts. Hier kommt Gödel ins Spiel.
Die Beweisidee ist nicht «schwer», aber sie sprengt den Rahmen dieses Textes. (Wenn dich das interessiert: Sag’s,
dann schreibe ich gern eine separate Erklärung.)</p>
<p>Die Kernaussage ist: Egal, wie viele Axiome du aufschreibst — es wird immer wahre Aussagen geben, die sich aus deinen
Axiomen nicht beweisen lassen. Mathematik ist also unvollständig. Selbst mit «fünf Milliarden» Axiomen wirst du nie
alle wahren mathematischen Aussagen beweisen können.</p>
<h3 id="was-bedeutet-das">Was bedeutet das?</h3>
<p>Die Hoffnung war einmal: Wenn wir nur genug forschen und schlau genug werden, können wir alles beweisen.
Gödel zeigt: Nein — es gibt prinzipielle Grenzen.</p>
<p>Für mich folgt daraus: Egal, wie unser formales Denksystem aussieht, es bleiben immer Dinge, die für uns in diesem
System unzugänglich sind. Praktisch heisst das: Man braucht eine Art, mit «nicht beweisbaren» Aussagen umzugehen.
Aber man darf auch nicht ins andere Extrem kippen und behaupten, alles sei unbeweisbar. Schon die Behauptung,
etwas sei unbeweisbar, kann (in einem anderen System) wieder beweisbar sein.</p>
<p>Wichtig: Das bedeutet nicht, dass man «nichts» beweisen kann. Mathematische Beweise liefern eine Art Gewissheit, die
im Alltag selten vorkommt. Ich bin mir sicherer, dass es keine grösste Primzahl gibt, als dass ich einen Vater und
eine Mutter habe. Letzteres ist zwar praktisch sicher, aber nicht logisch zwingend. Mathematische Gewissheit ist —
wenn sie einmal sauber bewiesen ist — unerbittlich.</p>
<h2 id="komplexitatstheorie">Komplexitätstheorie</h2>
<p>Als Informatiker bin ich ständig mit Analysen über die Komplexität von Algorithmen konfrontiert. «Algorithmus» klingt
gross, meint aber oft etwas Banales: einen Prozess, ein Verfahren. Zum Beispiel: der kürzeste Weg von A nach B.
Man kann dann fragen, wie viel Zeit dieser Prozess im Durchschnitt, im besten oder im schlimmsten Fall braucht.</p>
<p>Komplexitätstheorie handelt genau von solchen Fragen: Was ist schneller? Was lässt sich optimieren?
Bevor ich Informatik studierte, dachte ich naiv: «Wenn man nur sauber programmiert, wird es schnell.» Das stimmt
manchmal — aber nicht immer. Manche Probleme bleiben langsam, selbst wenn man sie optimal implementiert.</p>
<p>Es gibt Aufgaben, die in der Praxis gut lösbar sind (z. B. sortieren, kürzeste Wege in grossen Netzen). Andere werden
aber sehr schnell absurd schwierig. Ein Beispiel ist Routenplanung mit vielen Zwischenstopps, bei denen die Reihenfolge
egal ist (klassisch: Varianten des Traveling-Salesman-Problems): Das skaliert exponentiell.</p>
<p>Und selbst bei Problemen, für die wir den «optimalen» Algorithmus kennen, kann das Ergebnis praktisch unbrauchbar sein.
Schach ist ein schönes Beispiel: Perfektes Schach lässt sich «in Prinzip» berechnen, aber der dafür nötige Aufwand ist
so gewaltig, dass das Universum eher aufhört zu existieren, als dass der Algorithmus fertig wird.</p>
<h3 id="was-bedeutet-das_1">Was bedeutet das?</h3>
<p>Nach Gödel kommt hier eine andere Art von Grenze: Es gibt Probleme, die <em>lösbar</em> sind. Es gibt eine eindeutige
Antwort, und wir wissen sogar, wie man sie findet. Und trotzdem sind sie so langsam, dass sie praktisch als
unlösbar gelten müssen.</p>
<p>Das ist weniger abstrakt als Gödel. Es gibt eine ganze Klasse solcher Probleme (Stichworte: NP‑vollständig,
EXP‑Time). Wären diese effizient lösbar, sähe unsere Welt anders aus: neue Medikamente, optimierter Verkehr,
und gleichzeitig wären viele Verschlüsselungsverfahren kaputt.</p>
<p>Und wichtig: Das ist nicht «nur» eine Grenze des Menschen. Wenn es keinen schnellen Algorithmus gibt, dann ist das
auch eine Grenze für Maschinen — auch für KI.</p>
<h2 id="halteproblem">Halteproblem</h2>
<p>Spätestens hier ist endgültig klar: Informatik.</p>
<p>Das Halteproblem ist ein Thema, von dem viele nie hören — ausser sie studieren Informatik oder interessieren sich
privat dafür. Und doch wäre die Welt völlig anders, wenn es lösbar wäre. Aber es ist es nicht.</p>
<p>Worum geht es?</p>
<p>Wir betrachten einen Algorithmus (ein Programm) und fragen: Hält er an — oder läuft er für immer?
Die erste Intuition ist: «Schau den Code an. Wenn da eine Schleife ist, dann weiss man es.» Leider gibt es sehr viele
Programme, bei denen man gerade <em>nicht</em> entscheiden kann, ob sie anhalten.</p>
<h3 id="was-bedeutet-das_2">Was bedeutet das?</h3>
<p>Vorher hatten wir Probleme, die «nur» praktisch unlösbar sind. Jetzt kommt etwas Seltsameres:</p>
<p>Ein Programm ist eindeutig. Entweder hält es an oder es hält nicht an. Dazwischen gibt es nichts.
Und trotzdem gibt es keinen allgemeinen Prozess, der diese Frage für beliebige Programme zuverlässig beantworten kann.</p>
<h2 id="chaostheorie">Chaostheorie</h2>
<p>Eine weitere Einschränkung unserer Möglichkeiten: Chaos.</p>
<p>«Chaos» meint hier nicht Alltagchaos, sondern einen mathematischen Begriff. Ein chaotisches System entwickelt sich je
nach kleinsten Unterschieden im Ausgangszustand in völlig unterschiedliche Richtungen. Der Klassiker ist das
Doppelpendel: Die Bewegung ist durch Naturgesetze klar bestimmt — und trotzdem ist es praktisch unmöglich,
hinreichend weit in die Zukunft präzise vorherzusagen, wo es nach 100 Sekunden sein wird.</p>
<p>Viele relevante Systeme verhalten sich in diesem Sinn chaotisch: Wetter, langfristige Bahnprognosen, komplexe
Stoßsysteme (z. B. viele Billardkugeln), und auch biologische bzw. medizinische Prozesse. Könnten wir diese Systeme
zuverlässig «lösen», hätten wir Therapien für eine Vielzahl von Krankheiten.</p>
<h3 id="was-bedeutet-das_3">Was bedeutet das?</h3>
<p>Wieder eine Grenze — aber diesmal sehr praktisch.</p>
<p>Manche behaupten (oft nicht Wissenschaftler), die Welt bestehe «im Grunde» nur aus ein paar Naturgesetzen, und alles
andere sei nur Ableitung. Daran ist einiges schief. Schon unsere aktuelle Physik ist kein vollständiges,
widerspruchsfreies Gesamtbild. Und selbst wenn sie es wäre: Chaos bleibt.</p>
<p>Um von kleinen Systemen verlässlich auf grosse zu schliessen, müssten wir chaotische Effekte vollständig kontrollieren.
Das gelingt in idealisierten Modellen vielleicht — in der realen Welt aber selten.</p>
<p>Das zwingt uns zu Abstraktionen, die nicht einfach «aus der Physik heraus» deduzierbar sind. Physik ersetzt nicht
Chemie, Chemie ersetzt nicht Biologie, und bei Psychologie und Soziologie wird es erst recht schwierig.</p>
<p>Folge: Wir müssen oft mit statistischen, vereinfachenden und (im strengen Sinn) «falschen» Theorien arbeiten, weil
die präzisere Wahrheit für uns unerreichbar bleibt. Das macht solche Modelle nicht wertlos — nur begrenzt.</p>
<h2 id="gradientenoptimierung">Gradientenoptimierung</h2>
<p>Das waren einige harte Grenzen. Sind wir damit grundsätzlich gelähmt?</p>
<p>Nicht ganz. Statt einer universellen Theorie können wir oft eine universelle Methode nutzen: Optimierung.</p>
<p>Im maschinellen Lernen wird das sehr konkret: Man baut ein System, das wenig «versteht». Es nimmt die Welt wahr, aber
kennt die zugrunde liegenden Gesetze nicht. Dann gibt man ihm ein Feedback‑Signal: Wie gut war diese Aktion?
Und das System versucht nicht zuerst, alles zu erklären, sondern iterativ besser zu werden.</p>
<p>Das Bild dazu: Ein Roboter steht am Berg und sieht nur einen Meter weit. Statt zu jammern, dass er den Gipfel nicht
sieht und deshalb keinen perfekten Plan machen kann, macht er einfach den nächsten Schritt bergauf — und dann den
nächsten. Irgendwann ist er oben. Vielleicht nicht auf dem Mount Everest, aber auf einem Berg, den er tatsächlich
erreichen konnte.</p>
<h3 id="was-bedeutet-das_4">Was bedeutet das?</h3>
<p>Dieser Ansatz «belebt» die gelähmte Person: Man kann weitergehen, auch ohne allwissenden Plan.</p>
<p>Und das gilt nicht nur für Wissenschaft. Auch im Alltag ist der nächste sinnvolle Schritt oft besser als ein
grandioser Masterplan. Statt «das Problem komplett lösen» kann man eine kleine Verbesserung machen. Statt «die Ehe
retten» kann man heute ein ehrliches Kompliment machen. Statt «die Firma umkrempeln» kann man einem Kunden freundlich
begegnen.</p>
<p>Es nimmt Druck raus: Man muss nicht alles verstehen, um anfangen zu handeln.</p>
<p>Der einzige «Plan» ist: Tu etwas Kleines und Gutes, von dem du begründet glaubst, dass es hilft.</p>
<h2 id="spieltheorie">Spieltheorie</h2>
<p>Ah ja, Spieltheorie: das oft belächelte Stiefkind der Soziologie.
Man wirft ihr vor, sie sei «unwissenschaftlich», weil sie mit Modellen arbeitet, die offensichtlich nicht die ganze
Realität abbilden. Das stimmt — aber das gilt für fast alle Modelle. Und die Einsichten können trotzdem wertvoll sein.</p>
<p>Spieltheorie versucht, menschliche Interaktionen als Spiel zu formalisieren und dann zu analysieren, was unter
bestimmten Annahmen rationales Verhalten wäre.</p>
<p>Ein klassisches Beispiel ist die «Tragödie der Allmende» (Tragedy of the Commons). Eine gemeinsame Wiese gehört dem
Dorf. Alle Bauern dürfen ihre Kühe darauf weiden lassen. Das Problem: Jeder einzelne Bauer profitiert davon, noch eine
Kuh zusätzlich zu schicken. Die Kosten — Überweidung, schlechtere Wiese — werden aber von allen gemeinsam getragen.</p>
<p>Selbst wenn niemand «böse» ist, entsteht so ein Mechanismus, der die gemeinsame Ressource zerstört. Und genau das ist
die Pointe: Nicht moralische Kategorien sind zuerst entscheidend, sondern Anreize und Strukturen.</p>
<p>Spieltheorie liefert hier eine Denkweise: Welche Regeln würden Kooperation stabil machen? Wie verändern sich
Ergebnisse, wenn man Gegenseitigkeit, Reputation oder Sanktionen einbaut? Und wenn ein System sogar unter der
Annahme egoistischer Akteure stabil wäre, dann ist das ein starkes Indiz, dass es auch in der Realität robust ist.</p>
<h3 id="was-bedeutet-das_5">Was bedeutet das?</h3>
<p>Neben konkreten Ergebnissen aus Modellen bringt Spieltheorie etwas sehr Nützliches: Sie zwingt dazu, Egoismus als
relevante Kraft ernst zu nehmen.</p>
<p>Egoismus wird oft moralisch abgewertet. Spieltheorie ist darin fast provokativ neutral: «Gut» ist erst einmal, was
mir nützt. Das ist unbequem — aber hilfreich, wenn man die Welt verstehen will.</p>
<p>Das relativiert auch Moral und Ethik in einem bestimmten Sinn: Welche Wirkung hat «gutes Handeln», wenn es gegenüber
anderen Strategien nicht bestehen kann? Handlungen müssen stark genug sein, um sich in der Welt zu behaupten.</p>
<p>Und ähnlich wie bei der Gradientenoptimierung schrumpft der Horizont: Nicht «die Welt retten» ist die Aufgabe,
sondern in einer lokalen und zeitlich begrenzten Situation die bestmögliche Entscheidung zu treffen.</p>
<h1 id="evolution-simulieren"><a href="/blog/science/simulating-evolution/">Evolution simulieren</a></h1>
<p>Viele Menschen behaupten, dass Evolution unmöglich ist, weil nichts aus Zufall entstehen kann. Aber ist Zufall der einzige Faktor in der Evolution? Was, wenn andere Kräfte im Spiel sind, die die Vielfalt und Komplexität des Lebens lenken? Um diese Frage zu erforschen, habe ich einen Algorithmus entwickelt, der Evolution simuliert und überraschende Ergebnisse zeigt.</p>
<p>Der Code ist unter <a href="https://github.com/risajef/pygame">GitHub</a> verfügbar.</p>
<p>Stell dir eine leere Welt vor. Ohne Sinn und Möglichkeiten. In dieser Welt taucht ein Roboter auf. Er kann nichts sehen. Sein visueller Input ist so leer wie das Universum, in dem er erschaffen wurde. Der Roboter hat keinen Willen. Er tut einfach etwas Zufälliges. Was er nicht weiss: Es gibt 50 andere Roboter, die gleichzeitig erschaffen wurden. Sie verhalten sich alle unterschiedlich. Einige wandern herum, einige stehen still, und einige drehen sich im Kreis. Dann tritt plötzlich eine änderung bei einem Roboter auf. Sein Input ändert sich. Er sieht etwas Rotes. Die anderen am selben Ort sehen es auch. Sie verhalten sich zufällig. Manche bewegen sich darauf zu, manche nicht. Was ist dieses rote Ding? Je näher ein Roboter kommt, desto klarer sieht er es, bis er es berühren kann. Von nichts bist du gekommen, und zu nichts wirst du zurückkehren. Der Roboter verschwindet. Jeder Roboter, der das rote Ding berührt, verschwindet. Er stirbt. Im Laufe der Zeit bleiben nur die Roboter, die sich entweder nicht bewegen oder vermeiden, das rote Ding zu berühren. Das geschieht automatisch, einfach durch die Gesetze dieses Universums. Wenn Roboter verschwinden, werden neue zufällig erschaffen und in die Welt geworfen, um die Bevölkerung vor dem Aussterben zu bewahren. Und es ward Abend und Morgen. Der erste Tag.</p>
<p>Am zweiten Tag stand ihnen ein neues Problem gegenüber. Es gab Gerüchte über ein grünes Ding. Die meisten Roboter verhielten sich gegenüber den grünen Dingen gleich, da die Evolution vorsichtige Individuen begünstigte. Aber einige Roboter verschwanden einfach, ohne die roten berührt zu haben. Ihre Lebensspanne war abgelaufen, und sie hatten das Geheimnis des Überlebens nicht herausgefunden. Nun ja, die meisten hatten es nicht. Einige hatten das zufällige Verhalten, sich den grünen Dingen zu nähern. Und als sie sie berührten, geschah etwas Magisches. Erstens verlängerten sie unwissentlich ihre Lebensspanne, und zweitens reproduzierten sie sich. Sie erstellten eine Kopie von sich selbst, sehr ähnlich, aber leicht anders, mit einer zufälligen Variation im Verhalten. Das ändert alles. Anstatt nicht zu sterben, wurde Reproduktion das neue Ziel des Spiels. Bald vermieden alle Roboter das rote Zeug und suchten das grüne Zeug.</p>
<p>Jetzt kommt die nächste Etappe. Vorher war Vorsicht der Schlüssel. Bewege dich langsam, um das Risiko zu reduzieren, versehentlich die roten Minen zu berühren. Aber nach einiger Zeit wurden einige Roboter zufällig schneller, und sie waren immer die ersten bei den grünen magischen Früchten. Die vorsichtigen Roboter verhungerten, weil die schnelleren zuerst da waren. Geschwindigkeit ist jetzt der Schlüssel. Aber sie müssen jetzt mehr Risiken eingehen. Viele Roboter sterben jetzt wegen der Minen, aber solange sie sich schneller vermehren, dominieren sie diese Welt.</p>
<p>Die letzte Etappe. Jetzt haben die Roboter ohne menschliches Eingreifen nützliches Verhalten entwickelt, einfach weil sie dieser sehr spezifischen Umgebung ausgesetzt waren. Jetzt bleibt nur noch eine letzte Optimierung. Sie müssen langsam, aber sicher die Minen vermeiden und ihre Basisgeschwindigkeit maximieren. Nach dieser Entwicklung wird ein Gleichgewicht erreicht, und aus reiner Zufälligkeit ohne Programmierung ist intelligentes Verhalten in Bezug auf diese Umgebung entstanden.</p>
<hr />
<iframe width="560" height="315" src="https://www.youtube.com/embed/ietVz2V5iDI?si=oZbGKo8A3-BdxUVX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Nicht-optimierte Roboter</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/w4fR5Zr0aZo?si=oZbGKo8A3-BdxUVX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Optimierte Roboter</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/D7IjajvfVnw?si=oZbGKo8A3-BdxUVX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Sichtfeld des Roboters visualisiert</p>
<h1 id="pytorch-ist-langsam-und-schnell-unter-windows"><a href="/blog/science/pytorch-is-slow-and-fast-on-windows/">PyTorch ist langsam und schnell unter Windows</a></h1>
<p>Für ein Projekt bei der Arbeit musste ich ein neuronales Netzwerk trainieren. Ich habe einen Windows-Laptop mit einer guten GPU. Wenn ich unter Windows entwickle, ist mein erster Ansatz, im <a href="https://learn.microsoft.com/de-de/windows/wsl/">WSL</a> (Windows Subsystem für Linux) zu arbeiten. Und es funktionierte auch. Ich bemerkte jedoch, dass meine GPU-Nutzung nicht optimal war. Deshalb habe ich es auch unter nativem Windows ausgeführt.</p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Nativ Windows</th>
<th>WSL</th>
</tr>
</thead>
<tbody>
<tr>
<td>Training</td>
<td>2.2 it/s</td>
<td>1.3 it/s</td>
</tr>
<tr>
<td>Eval</td>
<td>~5 it/s</td>
<td>1.5it/s</td>
</tr>
<tr>
<td>Thread-Erstellung</td>
<td>46s</td>
<td>~5s</td>
</tr>
<tr>
<td>Thread-Erstellung</td>
<td>54s</td>
<td>~5s</td>
</tr>
<tr>
<td>GPU-Nutzung Training</td>
<td><img alt="Bild" src="/assets/images/GPU_1_1.png" /></td>
<td><img alt="Bild" src="/assets/images/GPU_2_1.png" /></td>
</tr>
<tr>
<td>GPU-Nutzung Val</td>
<td><img alt="Bild" src="/assets/images/GPU_1_2.png" /></td>
<td><img alt="Bild" src="/assets/images/GPU_2_2.png" /></td>
</tr>
</tbody>
</table>
<p>Ich habe dieses Wissen genutzt, indem ich jetzt unter nativem Windows laufe, aber mit persistenten Workers, sodass die Threads nicht in jeder Epoche neu erstellt werden müssen.</p>
<p>Natürlich ist dies nur ein Beispiel. Mit einer anderen PyTorch-Version könnte sich das ändern. Vielleicht verhält es sich mit einer anderen GPU anders.</p>
<p>Die langsame Thread-Erstellung ist ein bekanntes Problem, wenn man Foren betrachtet, aber die signifikante Leistungssteigerung bei Verwendung von nativem Windows war unerwartet.</p>
<blockquote>
<p><a href="https://podman.io">Podman</a> ist genauso schnell wie natives WSL.</p>
<p><a href="https://anaconda.com">Anaconda</a> ist in diesem Setup auch nicht schneller als normales Python.</p>
</blockquote>
<h1 id="neuronale-netzwerke-komprimieren"><a href="/blog/science/compressing-neural-networks/">Neuronale Netzwerke komprimieren</a></h1>
<p>Als ich mich um eine PhD-Position beworben habe, wollte ich dem Professor einen Grund geben, mich anzuheuern – also habe ich eine meiner Ideen umgesetzt. Ich vermutete, dass die Gewichte neuronaler Netzwerke zu dicht sind. Es gibt viel Redundanz. Die konventionelle Methode zur Reduktion der Komplexität besteht darin, einen Engpass in die Architektur des neuronalen Netzwerks einzuführen. Das ist jedoch eine ressourcenintensive Lösung. Anstatt die Anzahl der Gewichte zu reduzieren, erhöhen wir sie. Eine weitere Möglichkeit, die Komplexität eines Modells zu reduzieren, besteht darin, die Präzision der Gewichte zu senken, z.B. von 32-Bit auf 8-Bit. Das ist ein legitimer Ansatz, aber wenig inspirierend. Und es ist schwer zu glauben, dass das der einzige und richtige Weg für alle Situationen ist.</p>
<p>Meine Hypothese war, die Gewichtsmatrix mit einem gängigen Algorithmus wie JPEG zu komprimieren. Ich nahm MNIST und trainierte ein kleines CNN:</p>
<pre><code class="language-python">hidden_layer_size = 512
linear1 = torch.nn.Linear(784, hidden_layer_size, bias=True)
linear2 = torch.nn.Linear(hidden_layer_size, 10, bias=True)
relu = torch.nn.ReLU()

model = torch.nn.Sequential(linear1, relu, linear2)
</code></pre>
<p>Die Grösse von 512 für die Hidden Layers war die erste Zweierpotenz, die gute Ergebnisse lieferte.</p>
<p>Die 784 stammt aus der Eingabegrösse, die 28 × 28 beträgt.</p>
<p>Die Hidden Layer ist somit eine Liste von 512 verschiedenen 28 × 28 Matrizen.</p>
<p>Ich nahm jede Matrix und komprimierte sie mit JPEG auf eine Qualität von nur 20%, verlor also viele Informationen, wie hier zu sehen:</p>
<p><img alt="Unkomprimiert" src="/assets/images/weight_uncompressed.png" />
<em>Zufällige unkomprimierte Gewichtsschicht</em></p>
<p><img alt="JPEG komprimiert 20% Qualität" src="/assets/images/weight_compressed.png" />
<em>Dieselbe Gewichtsschicht, aber mit JPEG komprimiert</em></p>
<p>Die Test-Accuracy sank nur von 97% auf 96%, was angesichts der geringeren Auflösung im latenten Raum bemerkenswert ist.</p>
<p>Die Gewichte in einem CNN sind sehr redundant. Mit einem naiven Algorithmus wie JPEG können wir die Dimensionalität deutlich reduzieren. Für die Vorwärtspropagation im Netzwerk brauche ich jedoch die Matrixversion von JPEG, die keinen Speicher spart. Die komprimierten Gewichte könnten verwendet werden, um sie über ein Netzwerk mit geringer Bandbreite wie das Internet zu übertragen. Wir können jedoch einige fundierte Annahmen treffen:</p>
<ul>
<li>Die Wahl einer anderen Basis für die Gewichte, etwa die Fourier-Basis, anstatt ein unabhängiges Gewicht an jeder Position, könnte die Erstellung grosser Netzwerke mit einer begrenzten Anzahl von Gewichten ermöglichen.</li>
<li>Diese Methode könnte auch in tiefen neuronalen Netzwerken funktionieren.</li>
<li>Die Entwicklung einer differenzierbaren Methode, die mit wenigen Parametern erhebliche Komplexität erzeugt, könnte die Rechenfähigkeiten bestehender Hardware verbessern.</li>
</ul>
<h1 id="ein-gescheitertes-experiment-gewichte-innerhalb-eines-neuronalen-netzwerks-komprimieren"><a href="/blog/science/a-failed-experiment-of-compressing-weights-inside-a-neural-network/">Ein gescheitertes Experiment: Gewichte innerhalb eines neuronalen Netzwerks komprimieren</a></h1>
<p>In neuronalen Netzwerken scheint es viele Gewichte zu geben, um auszudrücken, was wir wollen. Also dachte ich daran, die grundlegendste Operation – nämlich die Matrixmultiplikation – in einer komprimierten Version zu implementieren. Statt einfach zwei Matrizen zu multiplizieren, komprimieren wir die Gewichtsmatrix und multiplizieren diese. Ich benutzte Wavelet-Zerlegung mit einem Schwellenwert. Mein Ansatz war erfolgreich darin, die Gewichtsmatrix während des Trainings zu 75% auf Null zu setzen.</p>
<p>Ich benutzte so etwas:</p>
<pre><code class="language-python">coeffs = ptwt.wavedec(w_flat, &quot;haar&quot;, mode=&quot;zero&quot;)
coeffs_thresh = tuple(
                torch.where(torch.abs(c) &lt; threshold, torch.zeros_like(c), c)
                for c in coeffs
            )
w_compressed = ptwt.waverec(coeffs_thresh, &quot;haar&quot;)
</code></pre>
<p>Während das Netzwerk folgendermassen aussah:</p>
<pre><code class="language-python">class NetFC(nn.Module):
    def __init__(self):
        super(NetFC2, self).__init__()
        self.fc1 = CompressedLinear(784, 128, zero_fraction=0.75)
        self.fc2 = CompressedLinear(128, 64, zero_fraction=0.75)
        self.fc3 = CompressedLinear(64, 10, zero_fraction=0.75)

    def forward(self, x):
        x = x.view(-1, 784)
        x = self.fc1(x)
        x = F.relu(x)
        x = self.fc2(x)
        x = F.relu(x)
        x = self.fc3(x)
        return x
</code></pre>
<p>Dieses Netzwerk hat rund 100k Parameter, von denen 75k Null sein werden.</p>
<p>Aber der Leistungsabfall war zu hoch. Ich konnte meinen MNIST-Loss nur auf 0,55 bringen, während ein Netzwerk ohne Kompression, aber mit weniger (25k) Parametern problemlos 0,15 erreichte.</p>
<p>Es war also ein interessanter Ansatz, aber nicht erfolgreich.</p>
        </div>
    </div>
    <div id="mkdocs-search-popup">
        <button id="close-search-popup">&times;</button>
        <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
    </div>
    <a id="github-badge" href="https://github.com/risajef/risajef.github.io" target="_blank" 
        title="View source or create issues on GitHub">
        <svg viewBox="0 0 16 16" width="20" height="20" aria-hidden="true">
            <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
        </svg>
        <span>GitHub</span>
    </a>
    <a id="simple-analytics-badge"
        href="https://dashboard.simpleanalytics.com/retoweber.info?utm_source=retoweber.info&utm_content=badge&affiliate=woruk-rob"
        referrerpolicy="origin" target="_blank">
        <picture>
            <source srcset="https://simpleanalyticsbadges.com/retoweber.info?mode=dark"
                media="(prefers-color-scheme: dark)" /><img
                src="https://simpleanalyticsbadges.com/retoweber.info?mode=light" loading="lazy"
                referrerpolicy="no-referrer" crossorigin="anonymous" />
        </picture>
    </a>

    <script>
        function updateTocCollapse() {
            var toc = document.querySelector('.toc-list');
            if (!toc) return;
            if (window.innerWidth <= 900) {
                toc.classList.add('collapsed');
            } else {
                toc.classList.remove('collapsed');
            }
        }
        window.addEventListener('resize', updateTocCollapse);
        document.addEventListener('DOMContentLoaded', updateTocCollapse);
    </script>
    <script>
        var base_url = "../../..";
    </script>
    <script>
        // Show popup when search input is focused or typed in
        const searchInput = document.getElementById('mkdocs-search-query');
        const popup = document.getElementById('mkdocs-search-popup');
        const closeBtn = document.getElementById('close-search-popup');
        if (searchInput && popup && closeBtn) {
            searchInput.addEventListener('focus', () => { popup.style.display = 'block'; });
            searchInput.addEventListener('input', () => { popup.style.display = 'block'; });
            closeBtn.addEventListener('click', () => { popup.style.display = 'none'; });
            // Optional: hide popup when clicking outside
            document.addEventListener('mousedown', function (event) {
                if (popup.style.display === 'block' && !popup.contains(event.target) && event.target !== searchInput) {
                    popup.style.display = 'none';
                }
            });
        }
    </script>
    <script>
        (function () {
            function isExternalLink(anchor) {
                try {
                    var url = new URL(anchor.href, location.href);
                    return url.protocol.indexOf('http') === 0 && url.hostname !== location.hostname;
                } catch (e) {
                    return false;
                }
            }

            document.addEventListener('DOMContentLoaded', function () {
                var anchors = document.querySelectorAll('a[href]');
                anchors.forEach(function (a) {
                    // ignore anchors, mailto, tel, javascript:, and already-handled targets
                    var href = a.getAttribute('href') || '';
                    if (!href || href.indexOf('#') === 0 || href.indexOf('mailto:') === 0 || href.indexOf('tel:') === 0 || href.indexOf('javascript:') === 0) return;
                    if (isExternalLink(a)) {
                        a.setAttribute('target', '_blank');
                        // ensure security
                        var rel = (a.getAttribute('rel') || '').split(/\s+/).filter(Boolean);
                        if (rel.indexOf('noopener') === -1) rel.push('noopener');
                        if (rel.indexOf('noreferrer') === -1) rel.push('noreferrer');
                        a.setAttribute('rel', rel.join(' '));
                        // add class for styling
                        a.classList.add('external-link');
                    }
                });
            });
        })();
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../../assets/rss-feed.js"></script>
    <script src="../../../search/main.js"></script>
    <!-- 100% privacy-first analytics -->
    <script data-collect-dnt="true" async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
    <noscript><img src="https://queue.simpleanalyticscdn.com/noscript.gif?collect-dnt=true" alt=""
            referrerpolicy="no-referrer-when-downgrade" /></noscript>
</body>

</html>